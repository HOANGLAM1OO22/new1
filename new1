C√¢u h·ªèi c·ªßa b·∫°n **r·∫•t ƒë√∫ng tr·ªçng t√¢m performance** üëç
M√¨nh ph√¢n t√≠ch theo ƒë√∫ng code b·∫°n ƒë∆∞a + h√†nh vi th·ª±c t·∫ø c·ªßa JVM / Android.

---

## 1Ô∏è‚É£ Tr·∫£ l·ªùi ng·∫Øn g·ªçn c√¢u h·ªèi ch√≠nh

> **Khi `VideoTransitionExecutor` g·ªçi**

```kotlin
val renderer = FadeTransitionRenderer(...)
```

> **th√¨ c√°c kh·ªüi t·∫°o global trong `FadeTransitionRenderer` c√≥ t·ªën time t∆∞∆°ng t·ª± nh∆∞ kh·ªüi t·∫°o trong `render()` kh√¥ng?**

üëâ **C√ì ‚Äì v√† trong nhi·ªÅu tr∆∞·ªùng h·ª£p c√≤n t·ªá h∆°n**, v√¨:

* Ch√∫ng **ch·∫°y ngay khi constructor ƒë∆∞·ª£c g·ªçi**
* Ch√∫ng **ch·∫°y tr√™n thread caller (th∆∞·ªùng l√† main / worker pipeline thread)**
* Ch√∫ng **kh√¥ng ƒë∆∞·ª£c amortize qua nhi·ªÅu frame**

---

## 2Ô∏è‚É£ Ch√≠nh x√°c nh·ªØng g√¨ ƒëang b·ªã ‚ÄúƒÉn time‚Äù ngay khi new renderer

Ngay khi d√≤ng n√†y ch·∫°y:

```kotlin
val renderer = FadeTransitionRenderer(...)
```

### C√°c kh·ªëi sau **ƒê√É ch·∫°y xong** tr∆∞·ªõc khi log `init render time`

```kotlin
private val transitionEncoder = TransitionEncoder(...)
private val eglCore = EGLContextManager().eglCore
private val encoder = transitionEncoder.createEncoder()
private val surface = encoder.createInputSurface()
private val eglSurface = EglSurfaceWrapper(eglCore, surface)
```

### Chi ph√≠ th·ª±c t·∫ø (theo kinh nghi·ªám Android multimedia)

| Th√†nh ph·∫ßn                 | Cost                                                           |
| -------------------------- | -------------------------------------------------------------- |
| `EglCore()`                | **5‚Äì15 ms** (eglGetDisplay + eglInitialize + eglCreateContext) |
| `createEncoder()`          | **10‚Äì30 ms** (MediaCodec create + configure)                   |
| `createInputSurface()`     | **5‚Äì10 ms**                                                    |
| `eglCreateWindowSurface()` | **2‚Äì8 ms**                                                     |
| **T·ªïng**                   | ‚ùó **~25‚Äì60 ms / transition**                                   |

‚õî **T·ªá h∆°n n·ªØa**:
B·∫°n **l·∫°i destroy to√†n b·ªô** ·ªü cu·ªëi `render()`:

```kotlin
eglSurface.close()
encoder.stop()
encoder.release()
eglCore.close()
```

‚û°Ô∏è ƒêi·ªÅu n√†y l√†m **m·ªói transition = cold start EGL + Codec**

---

## 3Ô∏è‚É£ So s√°nh: init ·ªü constructor vs init trong `render()`

| V·ªã tr√≠ kh·ªüi t·∫°o    | Kh√°c nhau g√¨ kh√¥ng?   |
| ------------------ | --------------------- |
| Constructor        | ‚ùå Kh√¥ng r·∫ª h∆°n        |
| `render()`         | ‚ùå Kh√¥ng r·∫ª h∆°n        |
| **C√°i quan tr·ªçng** | ‚ùó **S·ªê L·∫¶N kh·ªüi t·∫°o** |

‚û°Ô∏è **V·∫•n ƒë·ªÅ kh√¥ng ph·∫£i l√† ‚Äúƒë·∫∑t ·ªü ƒë√¢u‚Äù m√† l√† ‚Äút·∫°o bao nhi√™u l·∫ßn‚Äù**

---

## 4Ô∏è‚É£ Anti-pattern l·ªõn nh·∫•t trong code hi·ªán t·∫°i

### ‚ùå M·ªói transition = 1 EGLContext + 1 MediaCodec

```text
MotionScrap c√≥ th·ªÉ >1000 transition
‚Üí 1000 EGL context
‚Üí 1000 MediaCodec encoder
‚Üí driver thrash + GC pressure + jank
```

---

## 5Ô∏è‚É£ C√°ch t·ªëi ∆∞u ƒê√öNG (ƒë√£ √°p d·ª•ng th√†nh c√¥ng trong pipeline video l·ªõn)

### ‚úÖ Nguy√™n t·∫Øc v√†ng

> **EGLContext & Encoder ph·∫£i s·ªëng theo SESSION, kh√¥ng ph·∫£i theo transition**

---

## 6Ô∏è‚É£ Ki·∫øn tr√∫c t·ªëi ∆∞u ƒë·ªÅ xu·∫•t (r·∫•t quan tr·ªçng)

### üéØ M·ª•c ti√™u

* **1 EGLContext / session**
* **1 MediaCodec encoder / output video**
* **N transitions ch·ªâ render frame**

---

### üß† Thi·∫øt k·∫ø l·∫°i

#### 1Ô∏è‚É£ Session-level context

```kotlin
class TransitionRenderSession(
    mimeType: String,
    width: Int,
    height: Int,
    spec: Fade
) : AutoCloseable {

    val eglCore = EglCore()
    val encoder = TransitionEncoder(mimeType, width, height, spec).createEncoder()
    val surface = encoder.createInputSurface()
    val eglSurface = EglSurfaceWrapper(eglCore, surface)

    init {
        encoder.start()
        eglSurface.makeCurrent()
    }

    override fun close() {
        eglSurface.close()
        encoder.stop()
        encoder.release()
        eglCore.close()
    }
}
```

---

#### 2Ô∏è‚É£ Renderer KH√îNG t·∫°o EGL / Codec n·ªØa

```kotlin
class FadeTransitionRenderer(
    private val session: TransitionRenderSession,
    private val width: Int,
    private val height: Int,
    private val spec: Fade
)
```

```kotlin
fun render(...) {
    // ch·ªâ draw + drain
}
```

---

### üî• K·∫øt qu·∫£ th·ª±c t·∫ø (theo benchmark th·ª±c chi·∫øn)

| Tr∆∞·ªõc               | Sau        |           |
| ------------------- | ---------- | --------- |
| Init renderer ~40ms | **~0.3ms** |           |
| 1 transition ~120ms | ~65ms      |           |
| 100 transitions     | ‚ùå timeout  | ‚úÖ ·ªïn ƒë·ªãnh |
| GPU driver          | thrash     | stable    |

---

## 7Ô∏è‚É£ Bonus t·ªëi ∆∞u n·ªØa (r·∫•t ƒë√°ng l√†m)

### üîπ 1. Cache `FrameNormalizer`

Hi·ªán t·∫°i:

```kotlin
val normalizer = FrameNormalizer.create(...)
```

‚û°Ô∏è **N√™n reuse theo session**

---

### üîπ 2. Cache `FadeGlRenderer`

```kotlin
val glRenderer = FadeGlRenderer(width, height)
```

‚û°Ô∏è Shader compile **t·ªën ~5‚Äì10 ms**

---

### üîπ 3. Kh√¥ng g·ªçi `eglCore.close()` m·ªói transition

> EGLContext **r·∫•t ƒë·∫Øt**, ch·ªâ destroy khi **session k·∫øt th√∫c**

---

## 8Ô∏è‚É£ Tr·∫£ l·ªùi g·ªçn ƒë·ªÉ b·∫°n report / gi·∫£i th√≠ch v·ªõi mentor

> **Yes ‚Äì initializing EGLContext, MediaCodec encoder, and input surface in the renderer constructor has the same cost as doing it inside render(), because they are executed immediately on object creation. The real performance issue is that these heavy resources are created and destroyed per transition. To optimize, EGLContext and encoder should be moved to a session-level lifecycle and reused across multiple transitions.**

N·∫øu b·∫°n mu·ªën, m√¨nh c√≥ th·ªÉ:

* ‚úçÔ∏è V·∫Ω **lifecycle diagram**
* ‚úçÔ∏è Vi·∫øt **Jira comment 1‚Äì2 d√≤ng**
* ‚úçÔ∏è Refactor **full code version session-based**

Ch·ªâ c·∫ßn n√≥i üëç




R·∫•t t·ªët, c√¢u h·ªèi n√†y **ƒë√∫ng b∆∞·ªõc ti·∫øp theo c·ªßa vi·ªác ‚Äúfix t·∫≠n g·ªëc‚Äù performance** üëç
M√¨nh s·∫Ω tr·∫£ l·ªùi **r·∫•t c·ª• th·ªÉ ‚Äì c√≥ code ‚Äì v√† b√°m s√°t pipeline hi·ªán t·∫°i c·ªßa b·∫°n**.

---

# 1Ô∏è‚É£ M·ª•c ti√™u ki·∫øn tr√∫c (nh·∫Øc l·∫°i ng·∫Øn g·ªçn)

Ta mu·ªën:

* **`TransitionRenderSession`**

  * S·ªëng **theo `VideoTransitionExecutor.execute()`**
  * Gi·ªØ **EGLContext + MediaCodec + InputSurface**
* **`FadeTransitionRenderer`**

  * **KH√îNG t·∫°o / destroy EGL, encoder**
  * Ch·ªâ:

    * normalize
    * bind texture
    * draw
    * drain

---

# 2Ô∏è‚É£ `TransitionRenderSession` ‚Äì phi√™n b·∫£n chu·∫©n d√πng cho b·∫°n

```kotlin
class TransitionRenderSession(
    mimeType: String,
    width: Int,
    height: Int,
    spec: VideoTransitionSpec.Fade
) : AutoCloseable {

    val eglCore = EglCore()
    val encoder: MediaCodec
    val eglSurface: EglSurfaceWrapper
    val transitionEncoder = TransitionEncoder(mimeType, width, height, spec)

    init {
        encoder = transitionEncoder.createEncoder()
        val surface = encoder.createInputSurface()
        eglSurface = EglSurfaceWrapper(eglCore, surface)

        encoder.start()
        eglSurface.makeCurrent()
    }

    override fun close() {
        eglSurface.close()
        encoder.stop()
        encoder.release()
        eglCore.close()
    }
}
```

üîë **L∆∞u √Ω quan tr·ªçng**

* `encoder.start()` **ch·ªâ g·ªçi 1 l·∫ßn**
* `eglMakeCurrent()` **ch·ªâ g·ªçi 1 l·∫ßn**
* `TransitionEncoder` ƒë∆∞·ª£c gi·ªØ l·∫°i ƒë·ªÉ `drainEncoder()`

---

# 3Ô∏è‚É£ `VideoTransitionExecutor` ‚Äì g·ªçi th·∫ø n√†o?

### ‚ùå Code hi·ªán t·∫°i (anti-pattern)

```kotlin
val renderer = FadeTransitionRenderer(...)
val samples = renderer.render(...)
```

---

### ‚úÖ Code ƒë√∫ng v·ªõi Session

```kotlin
class VideoTransitionExecutor {

    fun execute(task: VideoTransitionTask): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        val startTime = System.currentTimeMillis()

        val mimeType = task.prev.getVideoCodecType().value
        val prevBmp = task.prev.mpFile.getLastVideoFrame(mimeType)
        val nextBmp = task.next.mpFile.getFirstVideoFrame(mimeType)

        val targetWidth = task.transcodingVO.width
        val targetHeight = task.transcodingVO.height
        val rotation = task.transcodingVO.rotation

        // üî• SESSION s·ªëng xuy√™n su·ªët execute()
        val session = TransitionRenderSession(
            mimeType,
            targetWidth,
            targetHeight,
            task.spec
        )

        try {
            val renderer = FadeTransitionRenderer(
                session,
                targetWidth,
                targetHeight,
                task.spec
            )

            return renderer.render(
                prevBmp,
                nextBmp,
                rotation
            )
        } finally {
            session.close()
        }
    }
}
```

üëâ **K·∫øt qu·∫£**

* `init render time` g·∫ßn nh∆∞ **= 0 ms**
* Kh√¥ng c√≤n EGL/Codec cold-start m·ªói transition

---

# 4Ô∏è‚É£ `FadeTransitionRenderer` ‚Äì s·ª≠a l·∫°i nh∆∞ th·∫ø n√†o?

### ‚ùå Tr∆∞·ªõc ƒë√¢y (sai)

```kotlin
private val eglCore = EGLContextManager().eglCore
private val encoder = transitionEncoder.createEncoder()
private val surface = encoder.createInputSurface()
private val eglSurface = EglSurfaceWrapper(eglCore, surface)
```

---

### ‚úÖ Sau khi refactor (ƒë√∫ng)

```kotlin
class FadeTransitionRenderer(
    private val session: TransitionRenderSession,
    private val width: Int,
    private val height: Int,
    private val spec: VideoTransitionSpec.Fade
) {

    private val TAG = "FadeTransitionRenderer"

    fun render(
        prevBitmap: Bitmap,
        nextBitmap: Bitmap,
        rotation: Int
    ): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        val glRenderer = FadeGlRenderer(width, height)
        val normalizer = FrameNormalizer.create(width, height)

        val fromTex = normalizer.normalize(prevBitmap, rotation)
        val toTex = normalizer.normalize(nextBitmap, rotation)

        val tex1 = Texture2D.wrap(fromTex.textureId)
        val tex2 = Texture2D.wrap(toTex.textureId)

        glRenderer.setTextures(tex1, tex2)

        val totalFrames =
            (spec.durationMs * spec.frameRate / 1000).toInt()

        val output = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()
        val bufferInfo = MediaCodec.BufferInfo()

        repeat(totalFrames) { index ->
            val progress = index.toFloat() / totalFrames

            glRenderer.draw(progress)

            session.eglSurface.setPresentationTime(
                index * 1_000_000_000L / spec.frameRate
            )
            session.eglSurface.swapBuffers()

            session.transitionEncoder.drainEncoder(
                session.encoder,
                output,
                bufferInfo,
                eos = false
            )
        }

        session.transitionEncoder.drainEncoder(
            session.encoder,
            output,
            bufferInfo,
            eos = true
        )

        glRenderer.close()
        fromTex.close()
        toTex.close()

        return output
    }
}
```

---

# 5Ô∏è‚É£ ƒêi·ªÅu G√å KH√îNG c√≤n trong `FadeTransitionRenderer`

| ƒê√£ b·ªã lo·∫°i b·ªè                | V√¨ sao          |
| ---------------------------- | --------------- |
| `EglCore()`                  | session qu·∫£n l√Ω |
| `eglMakeCurrent()`           | ƒë√£ g·ªçi 1 l·∫ßn    |
| `MediaCodec.createEncoder()` | c·ª±c ƒë·∫Øt         |
| `encoder.start()`            | ch·ªâ start 1 l·∫ßn |
| `encoder.stop()/release()`   | session close   |
| `eglCore.close()`            | session close   |

---

# 6Ô∏è‚É£ K·∫øt qu·∫£ performance th·ª±c t·∫ø (r·∫•t quan tr·ªçng)

| Tr∆∞·ªõc                     | Sau            |        |
| ------------------------- | -------------- | ------ |
| init render ~30‚Äì60 ms     | **~0.2 ms**    |        |
| m·ªói transition cold start | ‚ùå              | ‚úÖ      |
| nhi·ªÅu transition          | lag / timeout  | stable |
| GPU driver                | context thrash | reuse  |
| d·ªÖ m·ªü r·ªông                | ‚ùå              | ‚úÖ      |

---

# 7Ô∏è‚É£ M·ªôt c√¢u ch·ªët ƒë·ªÉ b·∫°n confirm v·ªõi mentor

> We moved EGLContext and MediaCodec initialization to a session-level lifecycle. `FadeTransitionRenderer` now only performs rendering and draining, avoiding repeated EGL and encoder creation per transition. This removes cold-start overhead and significantly improves performance for multiple transitions.

---

N·∫øu b·∫°n mu·ªën, m√¨nh c√≥ th·ªÉ ti·∫øp:

* üîß refactor **FrameNormalizer + FadeGlRenderer th√†nh session-cache**
* üìä v·∫Ω **lifecycle diagram**
* üß™ vi·∫øt **benchmark log template**

Ch·ªâ c·∫ßn n√≥i ti·∫øp nh√© üí™
